c
connection.create_relationship(how, from, to)
c
connection.create_relationship(how, from, to)
TraitBank.create_trait(trait.symbolize_keys)
puts e
c
TraitBank.create_trait(trait.symbolize_keys)
puts e
c
puts trait["resource_pk"]
puts trait[:resource_pk]
puts trait[:predicate]["data"]["uri"]
puts trait[:predicate]["data"]
puts trait[:predicate]["data"}
puts trait[:predicate]
puts trait[:uri]
puts trait[:page]["data"]["page_id"]
puts trait[:page]["data"]
puts trait[:page]
puts trait.inspect ; 1
puts e.class
puts e
c
puts e.class
puts e
q
uri
c
puts e.class
puts e
q
TraitBank.count
c
options[:page]
options = trait.symbolize_keys
q
options[:page]
options = trait.symbolize_keys
q
options[:units]
options[:predicate]
options[:metadata]
options[:supplier]
tb_page = TraitBank.create_page(page_id).first
pages[page_id]
page_id
options[:page]
options[:resource_pk]
trait = TraitBank.trait_exists?(resource_id, options[:resource_pk])
trait = trait_exists?(resource_id, options[:resource_pk])
resource_id = options[:supplier]["data"]["resource_id"]
options = trait.symbolize_keys
resource_id = options[:supplier]["data"]["resource_id"]
trait = st
st = trait.symbolize_keys
c
page
resource_id
options
resource_id = options[:supplier]["data"]["resource_id"]
trait_exists?(resource_id, options[:resource_pk])
trait = trait_exists?(resource_id, options[:resource_pk])
puts trait
c
puts st.keys.first.class
puts st.keys.sort
st = trait.symbolize_keys
pp trait.keys ; 1
pp trait.symbolize_keys
pp trait.sybolize_keys
pp trait.keys
pp trait.keys.sort
pp trait ; 1
pp trait
q
klass.create(instance)
instance["parent_id"] = nil if instance["parent_id"] == 0
instance["parent_id"] == nil if instance["parent_id"] == 0
instance["parent_id"] == 0
instance["parent_id"].class
instance["parent_id"]
instance["id"]
instance["resource_id"]
klass.create(instance)
instance["admin"]
instance
puts e
q
resource = TraitBank.connection.create_node(resource_id: id)
TraitBank.find_resource(id)
id = 1
puts e.backtrace
puts e
q
options[:supplier]["data"]["resource_id"]
options[:supplier]["data"]
options[:supplier]
options.supplier
options.keys.sort
options.keys
options[:resource_pk]
options[:resource_id]
options
q
puts e.backtrace
puts e
q
TraitBank.create_resource(res_id).first
TraitBank.create_resource(res_id)
res_id
suppliers[res_id].is_a?(Array)
suppliers
res_id
suppliers[res_id]
q
res_id
c
suppliers[red_id]
res_id
suppliers
puts trait[:supplier]
quit
puts e
q
puts e.backtrace
to
from
how
puts e
puts e.class
exit
puts e.backtrace
puts e
q
puts e.class
puts e.backtrace
puts e
q
c
how
hoe
connection.create_relationship(how, from, to)
puts e.backtrace
puts e
q
puts e
c
puts e
puts e.backtrace
puts e
quit
puts e.backtrace
puts e
q
trait
puts e.backtrace
puts e
quit
puts e
q
res_id = Resource.first.id
pp trait
c
q
puts res_id.nil?
puts res_id
puts e
c
puts e
q
puts e.backtrace
c
trait[:metadata].map! { |md| md_pred = md.delete("predicate") ; md_val = md.delete("value_uri") ; md_unit = md.delete("units") ; md[:predicate] = terms[md_pred] || add_term(md_pred) ; md[:object_term] = terms[md_val] || add_term(md_val) ;  md[:units] = terms[md_unit] || add_term(md_unit) ; md[:literal] = md.delete("value_literal") ; md[:measurement] = md.delete("value_num") ;  md.symbolize_keys }
trait[:metadata] = trait.delete("metadata")
          }
            md.symbolize_keys
            # TODO: add those back as links...
            md[:measurement] = md.delete("value_num")
            # if there are units, we should have a measurement!
            # TODO: I would feel better if we did more to check the measurement;
            md[:literal] = md.delete("value_literal")
            md[:units] = terms[md_unit] || add_term(md_unit)
            md[:object_term] = terms[md_val] || add_term(md_val)
            md[:predicate] = terms[md_pred] || add_term(md_pred)
            md_unit = md.delete("units")
            md_val = md.delete("value_uri")
            md_pred = md.delete("predicate")
  trait[:metadata] = trait.delete("metadata").map { |md|
          trait[:object_term] = terms[val_uri] || add_term(val_uri)
          trait[:units] = terms[unit] || add_term(unit)
          trait[:predicate] = terms[pred] || add_term(pred)
          val_uri = trait.delete("value_uri")
          unit = trait.delete("units")
          pred = trait.delete("predicate")
          trait[:supplier] = suppliers[res_id] || add_supplier(res_id, suppliers)
          res_id = trait.delete("resource_id")
exit
quit
qu9it
irb
          end
            md.symbolize_keys
            # TODO: add those back as links...
            md[:measurement] = md.delete("value_num")
            # if there are units, we should have a measurement!
            # TODO: I would feel better if we did more to check the measurement;
            md[:literal] = md.delete("value_literal")
            md[:units] = terms[md_unit] || add_term(md_unit)
            md[:object_term] = terms[md_val] || add_term(md_val)
            md[:predicate] = terms[md_pred] || add_term(md_pred)
            md_unit = md.delete("units")
            md_val = md.delete("value_uri")
            md_pred = md.delete("predicate")
          trait[:metadata] = trait.delete("metadata").map do |md|
          trait[:object_term] = terms[val_uri] || add_term(val_uri)
          trait[:units] = terms[unit] || add_term(unit)
          trait[:predicate] = terms[pred] || add_term(pred)
          val_uri = trait.delete("value_uri")
unit = trait.delete("units")
pred = trait.delete("predicate")
trait[:supplier]
trait[:supplier] = suppliers[res_id] || add_supplier(res_id, suppliers)
res_id = trait.delete("resource_id")
q
puts e
c
res_id = trait.delete("resource_id")
q
trait[:supplier] = suppliers[res_id] || add_supplier(res_id, suppliers)
res_id = trait.delete("resource_id")
q
puts e
exit
trait
puts e
quit
puts e.backtrace[0..10]
puts e
quit
page.native_node.parent
parent_id = page.native_node.parent.page_id
page = Page.find(page_id)
Page.exists?(page_id)
tb_page = tb_page.first
tb_page = TraitBank.create_page(page_id)
page_id
add_page(page_id, pages)
quit
c
puts pages
puts page_id
quit
puts e
q
puts e
