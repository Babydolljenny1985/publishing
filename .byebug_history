q
klass.create(instance)
instance["parent_id"] = nil if instance["parent_id"] == 0
instance["parent_id"] == nil if instance["parent_id"] == 0
instance["parent_id"] == 0
instance["parent_id"].class
instance["parent_id"]
instance["id"]
instance["resource_id"]
klass.create(instance)
instance["admin"]
instance
puts e
q
resource = TraitBank.connection.create_node(resource_id: id)
TraitBank.find_resource(id)
id = 1
puts e.backtrace
puts e
q
options[:supplier]["data"]["resource_id"]
options[:supplier]["data"]
options[:supplier]
options.supplier
options.keys.sort
options.keys
options[:resource_pk]
options[:resource_id]
options
q
puts e.backtrace
puts e
q
TraitBank.create_resource(res_id).first
TraitBank.create_resource(res_id)
res_id
suppliers[res_id].is_a?(Array)
suppliers
res_id
suppliers[res_id]
q
res_id
c
suppliers[red_id]
res_id
suppliers
puts trait[:supplier]
quit
puts e
q
puts e.backtrace
to
from
how
puts e
puts e.class
exit
puts e.backtrace
puts e
q
puts e.class
puts e.backtrace
puts e
q
c
how
hoe
connection.create_relationship(how, from, to)
puts e.backtrace
puts e
q
puts e
c
puts e
puts e.backtrace
puts e
quit
puts e.backtrace
puts e
q
trait
puts e.backtrace
puts e
quit
puts e
q
res_id = Resource.first.id
pp trait
c
q
puts res_id.nil?
puts res_id
puts e
c
puts e
q
puts e.backtrace
c
trait[:metadata].map! { |md| md_pred = md.delete("predicate") ; md_val = md.delete("value_uri") ; md_unit = md.delete("units") ; md[:predicate] = terms[md_pred] || add_term(md_pred) ; md[:object_term] = terms[md_val] || add_term(md_val) ;  md[:units] = terms[md_unit] || add_term(md_unit) ; md[:literal] = md.delete("value_literal") ; md[:measurement] = md.delete("value_num") ;  md.symbolize_keys }
trait[:metadata] = trait.delete("metadata")
          }
            md.symbolize_keys
            # TODO: add those back as links...
            md[:measurement] = md.delete("value_num")
            # if there are units, we should have a measurement!
            # TODO: I would feel better if we did more to check the measurement;
            md[:literal] = md.delete("value_literal")
            md[:units] = terms[md_unit] || add_term(md_unit)
            md[:object_term] = terms[md_val] || add_term(md_val)
            md[:predicate] = terms[md_pred] || add_term(md_pred)
            md_unit = md.delete("units")
            md_val = md.delete("value_uri")
            md_pred = md.delete("predicate")
  trait[:metadata] = trait.delete("metadata").map { |md|
          trait[:object_term] = terms[val_uri] || add_term(val_uri)
          trait[:units] = terms[unit] || add_term(unit)
          trait[:predicate] = terms[pred] || add_term(pred)
          val_uri = trait.delete("value_uri")
          unit = trait.delete("units")
          pred = trait.delete("predicate")
          trait[:supplier] = suppliers[res_id] || add_supplier(res_id, suppliers)
          res_id = trait.delete("resource_id")
exit
quit
qu9it
irb
          end
            md.symbolize_keys
            # TODO: add those back as links...
            md[:measurement] = md.delete("value_num")
            # if there are units, we should have a measurement!
            # TODO: I would feel better if we did more to check the measurement;
            md[:literal] = md.delete("value_literal")
            md[:units] = terms[md_unit] || add_term(md_unit)
            md[:object_term] = terms[md_val] || add_term(md_val)
            md[:predicate] = terms[md_pred] || add_term(md_pred)
            md_unit = md.delete("units")
            md_val = md.delete("value_uri")
            md_pred = md.delete("predicate")
          trait[:metadata] = trait.delete("metadata").map do |md|
          trait[:object_term] = terms[val_uri] || add_term(val_uri)
          trait[:units] = terms[unit] || add_term(unit)
          trait[:predicate] = terms[pred] || add_term(pred)
          val_uri = trait.delete("value_uri")
unit = trait.delete("units")
pred = trait.delete("predicate")
trait[:supplier]
trait[:supplier] = suppliers[res_id] || add_supplier(res_id, suppliers)
res_id = trait.delete("resource_id")
q
puts e
c
res_id = trait.delete("resource_id")
q
trait[:supplier] = suppliers[res_id] || add_supplier(res_id, suppliers)
res_id = trait.delete("resource_id")
q
puts e
exit
trait
puts e
quit
puts e.backtrace[0..10]
puts e
quit
page.native_node.parent
parent_id = page.native_node.parent.page_id
page = Page.find(page_id)
Page.exists?(page_id)
tb_page = tb_page.first
tb_page = TraitBank.create_page(page_id)
page_id
add_page(page_id, pages)
quit
c
puts pages
puts page_id
quit
puts e
q
puts e
quit
puts e.backtrace[12..15]
puts e.backtrace[8..12]
puts e.backtrace[0..8]
puts e.backtrace[0..5]
puts e
exit
puts e.backtrace[0..3]
puts e
quit
puts e.backtrace
puts e
quit
pages[7662]
page[7662]
pages.keys.first
page
puts e.class
puts e.backtrace[7..15]
puts e.backtrace[0..6]
puts e
quit
reload!
reload
puts e.backtrace[0..3]
puts e
continue
extxt
g
gf
xt
exit
q
puts e
quit
puts e
quit
puts e
quit
puts e
q
puts e
quit
puts e
put e
puts e.backtrace[0..4]
puts e.backtrace.first
puts e.backtrace[0..200]
puts e.backtrace[0..1000]
puts e
exit
c
reload!
c
ex
puts e.backtrace
puts e
quit
q
puts e
q
puts e
quit
Rails.env.test?
Rails.test?
Rails.env
request.url
request.uri
request
link_to("foo", "bar")
original_url
current_url
current_page
current_path
q
