q
puts t_data["object_page"]
quit
puts id
puts @page.id
puts @page
c
display user
c
display user
c
display user
c
display response
c
display response
p response
c
skip
display response.body >> result
display response.body > result
display response.body
display response
c
~c
c
res
traits
c
ancestor_page_ids
ancestor_page_ids.each
c
ancestor_page_ids
c
clade_id
ancestors
c
params
param
c
quit
puts data.first
puts data.size
puts data.class
puts data["id"]
puts data
puts datas
c
rendered
c
 expect(rendered).to have_selector("div[class='*collection_search']")
rendered
c
c 
c
collection
c
cc
c
skip
c
p @collection
p @collection.class
p @collection.collected_pages
p @collection.class
p @collection.collected_pages
p @collection.collcted_pages
p @collection.colelcted_pages
p @collection.collections
p @collection
c
p @collection.id
p @collection.attributes
c
p @collection.attributes
p @collection
p @collection.id
p @collection
p collection
p controller
p @collection
c
c 
c
n
c
n
CollectedPage.find_page(params[:q], params[:collection_id]).results.to_json
CollectedPage.find_page(params[:q], params[:collection_id]).results
CollectedPage.find_page(params[:q], params[:collection_id])
CollectedPage.find_page(params[:q], params[:collection_id]).results
c
n
params[:collection_id]
params[:q]
c
n
params
c
params
c 
c
n
c
puts e.message =~ /already exists/
puts e.message
puts e
c
[predicate1, predicate2].sort { |a,b| a[:name] <=> b[:name] }.map { |p| p[:uri] }
[predicate1, predicate2].sort_by { |a,b| a[:name] <=> b[:name] }
predicate2
predicate1
[predicate1, predicate2].sort_by { |a,b| a[:name] <=> b[:name] }.map { |p| p[:uri] }
our_page.predicates
c
[predicate1.uri, predicate2.uri].sort
our_page.grouped_traits.keys.sort
c
[predicate1.uri, predicate2.uri].sort
our_page.grouped_traits.keys.sort
c
[predicate1.uri, predicate2.uri]
our_page.predicates
predicate1
our_page.instance_eval { glossary_names["http://uri.for/term28"] }
our_page.instance_eval { glossary_names["http://uri.for/term30"] }
our_page.instance_eval { grouped_traits.keys }
our_page.instance_eval { predicates }
our_page.instance_eval { glossary_names }
our_page.instance_eval { @glossary_names }
our_page.instance_eval { glossary_names }
our_page.instance_eval { @glossary }
our_page.instance_eval { @glossary_names }
puts our_page.predicates
our_page.instance_eval { @glossary_names = nil }
puts our_page.predicates
our_page.instance_eval { @predicates = nil }
our_page
puts our_page.predicates
quit
puts params
q
puts params
puts new_item_params
exit
our_page.preferred_vernaculars.current_language
our_page.vernaculars.loaded?
our_page.preferred_vernaculars.loaded?
language ||= Language.english
pref_name.string
our_page.name
q
Page.find(96)
page
page.native_node_id
Node.where(id: page.native_node_id)
page.native_node
Node.last
params
page.collect_as
page.id
page = Page.find(96)
item
Page.find(item.id).collect_as
Page.find(item).collect_as
Item.find(item).collect_as
item.collect_as
item.collected_as
item
n
q
CollectionItem.find(9)
params
para,s
@collection.collection_items.create
@collection.collection_items
@collection
q
c
page
c
page
c
page
q
c
glossary
c
q
p grouped_traits
c
q
@traits.map { |t| t["page_id"]
@traits
q
p u_data
exit
reload!
p u_data
p udata
exit
p v_data
c
our_page.traits
q
our_page.traits
our_page.glossary
q
cs = ContentSection.create(content: article, section: Section.brief_summary)
p Section.brief_summary
c
ContentSection.create(content: article, section: Section.brief_summary)
quit
Medium.subclasses[subclass]
subclass = :image
Medium.last
c
subclass
klass
c
klass
subclass
sublcass
c
c_data.delete("type")
options[:subclass]
subclass
q
c
Import::Page.class_eval { pp @resource_nodes }
@resource_nodes
meta
page
supplier
options
supplier
c
supplier
connection
pp page
pp trait
c
pp options
