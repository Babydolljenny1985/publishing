#term_form_container
  = form_for @query, :url => term_search_results_path, :method => :get, :html => { :id => "new_term_query", :class => ["uk-form", "uk-form-horizontal", "js-filter-form", ("is-multiple-filters" if (@query.filters.length > 1))]} do |f|
    - if @query.errors[:base].any?
      %ul.base-errors
        - @query.errors.full_messages_for(:base).each do |e|
          %li= e

    .filter.filter-row
      %span.js-typeahead-wrap.l-filter-full
        = text_field_tag "clade_name", f.object.clade&.native_node&.canonical_form, :class => "js-clade-typeahead uk-input", :placeholder => "clade (optional)"
        = f.hidden_field :clade_id, :class => "js-typeahead-field"

    = f.fields_for :filters do |ff|
      .filter.uk-form-row
        - if f.object.filters.length > 1
          .l-filter-first.filter-icon
            .js-remove-filter{:'uk-icon' => "icon: close; ratio: 1.4", :data => { :index => ff.index }}
        %span.js-typeahead-wrap.filter-field.l-filter-full.filter-row{:class => ff.object.errors[:pred_uri].any? ? "is-filter-row-with-errors" : ""}
          = text_field_tag "pred_name", pred_name(ff.object.pred_uri), :class => "uk-input js-pred-typeahead", :placeholder => "attribute"
          = ff.hidden_field :pred_uri, :class => "js-typeahead-field"
          - show_error(ff.object, :pred_uri)
        - if ff.object.units_for_pred?
          .filter-row{:class => (ff.object.errors[:num_val1].any? || ff.object.errors[:num_val2].any?) ? "is-filter-row-with-errors" : ""}
            %span.filter-field
              = ff.text_field :num_val1, :class => "filter-input uk-input uk-form-width-small", :placeholder => "-∞"
              - show_error(ff.object, :num_val1)
            %span.filter-txt to
            %span.filter-field
              = ff.text_field :num_val2, :class => "filter-input uk-input uk-form-width-small", :placeholder => "∞"
              - show_error(ff.object, :num_val2)
          .filter-row{:class => ff.object.errors[:obj_uri].any? ? "is-filter-row-with-errors" : ""}
            = ff.select :units_uri, units_select_options(ff.object), {}, :class => "filter-input uk-select l-filter-full"
        - else
          - # If there's a predicate, restrict typeahead to objects for that predicate, o/w allow all 
          - typeahead_class = ff.object.predicate? ? "pred-obj" : "obj"
          .filter-row{:class => ff.object.errors[:obj_uri].any? ? "is-filter-row-with-errors" : ""}
            %span.js-typeahead-wrap.filter-field.l-filter-full
              = text_field_tag "obj_name", obj_name(ff.object.obj_uri), :class => "js-#{typeahead_class}-typeahead uk-input", :data => { :'pred-uri' => ff.object.pred_uri }, :placeholder => "value"
              = ff.hidden_field :obj_uri, :class => "js-typeahead-field"
              - show_error(ff.object, :obj_uri)
        - if ff.object.show_meta?
          .filter-row{:class => ff.object.errors[:sex_uri].any? ? "is-filter-row-with-errors" : ""}
            %span.js-typeahead-wrap.filter-field.l-filter-full
              = text_field_tag "sex_name", term_name(ff.object.sex_uri), :class => "js-meta-obj-typeahead uk-input", :data => { :'pred' => 'sex' }, :placeholder => "sex term"
              = ff.hidden_field :sex_uri, :class => "js-typeahead-field"
              - show_error(ff.object, :sex_uri)
          .filter-row{:class => ff.object.errors[:lifestage_uri].any? ? "is-filter-row-with-errors" : ""}
            %span.js-typeahead-wrap.filter-field.l-filter-full
              = text_field_tag "lifestage_name", term_name(ff.object.lifestage_uri), :class => "js-meta-obj-typeahead uk-input", :data => { :'pred' => 'lifestage' }, :placeholder => "lifestage"
              = ff.hidden_field :lifestage_uri, :class => "js-typeahead-field"
              - show_error(ff.object, :lifestage_uri)
          .filter-row{:class => ff.object.errors[:statistical_method_uri].any? ? "is-filter-row-with-errors" : ""}
            %span.js-typeahead-wrap.filter-field.l-filter-full
              = text_field_tag "statistical_method_name", term_name(ff.object.statistical_method_uri), :class => "js-meta-obj-typeahead uk-input", :data => { :'pred' => 'stat_meth' }, :placeholder => "statistical method"
              = ff.hidden_field :statistical_method_uri, :class => "js-typeahead-field"
              - show_error(ff.object, :statistical_method_uri)
          .filter-row{:class => ff.object.errors[:resource].any? ? "is-filter-row-with-errors" : ""}
            %span.js-typeahead-wrap.filter-field.l-filter-full
              = text_field_tag "resource_name", ff.object.resource&.name, :class => "js-resource-typeahead uk-input", :placeholder => "resource"
              = ff.hidden_field :resource_id, :class => "js-typeahead-field"
              - show_error(ff.object, :resource)
          .filter-row
            .a.js-hide-meta-filters{ data: { index: ff.index } } hide metadata fields
        - else
          .filter-row
            .a.js-show-meta-filters{ data: { index: ff.index } } show metadata fields
        = ff.hidden_field :show_meta

    .filter-row
      .filter.add-filter.js-add-filter
        %span.filter-icon{:'uk-icon' => "icon: plus; ratio: 1.4"}
        .filter-txt trait filter
    .filter-row.filter-row-flex
      .filter-radios
        .filter-field.filter-field-radio
          = label_tag :search_type_page, "taxa matching ALL filters"
          = f.radio_button :result_type, :taxa
        .filter-field.filter-field-radio
          = label_tag :search_type_record, "records matching ALL filters"
          = f.radio_button :result_type, :record
    = submit_tag "Search", :class => "submit uk-button uk-button-primary uk-button-large uk-width-1-1 js-term-search-submit"
